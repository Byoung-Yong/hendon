<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PSD Analyzer by Hendon's Coffee Research Group</title>
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/Hendon-Coffee-Research/Grinder-Trauma-Model/main/assets/coffee_ico.png">
    <!-- Tailwind & Chart.js -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body{font-family:'Inter',sans-serif;background-color:#f1f5f9;}
        .fit-results-table{width:100%;border-collapse:collapse;font-size:0.875rem;}
        .fit-results-table th,.fit-results-table td{border:1px solid #e2e8f0;padding:10px;text-align:left;}
        .fit-results-table th{background-color:#f8fafc;}
        .fit-results-table tr:nth-child(even){background-color:#f8fafc;}
        .results-value { text-align: right; font-weight: 500; }
    </style>
</head>
<body class="text-slate-800 flex flex-col items-center min-h-screen p-4 sm:p-6">

<!-- Main Analyzer Panel -->
<div class="w-full max-w-7xl bg-white rounded-2xl shadow-lg border border-slate-200 overflow-hidden">

    <header class="text-center p-8 bg-gradient-to-b from-blue-800 to-blue-500 text-white">
        <h1 class="text-3xl sm:text-4xl font-bold tracking-tight">Hendon's Coffee Research Group</h1>
        <p class="mt-2 text-lg text-blue-100">Particle Size Distribution (PSD) Analyzer - Espresso Grind</p>
    </header>

    <main class="grid grid-cols-1 md:grid-cols-3 gap-8 p-6 sm:p-8">

        <!-- Left Column -->
        <div class="md:col-span-1 flex flex-col gap-8">
            <!-- Data Input -->
            <div class="flex flex-col">
                <h2 class="text-xl font-semibold text-blue-800 mb-4">Data Input</h2>
                <label for="dataInput" class="block text-sm font-medium text-slate-700 mb-2">Paste your data in Size (µm), Distribution format:</label>
                <textarea id="dataInput" rows="10" class="w-full p-4 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition-shadow duration-200 shadow-sm" placeholder="Example:&#10;10, 2&#10;100, 25&#10;500, 18">10, 0
11.481536, 1.10099
13.182567, 2.355036667
15.135612, 3.666760667
17.378008, 4.953392667
19.952623, 6.000833667
22.908677, 6.683302333
26.30268, 6.928162
30.199517, 6.738784
34.673685, 6.193543333
39.810717, 5.433741
45.708819, 4.620944667
52.480746, 3.911284333
60.255959, 3.420793333
69.183097, 3.200315667
79.432823, 3.235170667
91.201084, 3.448564333
104.712855, 3.721858667
120.226443, 3.935634667
138.038426, 3.986896667
158.489319, 3.821926667
181.970086, 3.446172667
208.929613, 2.897496333
239.883292, 2.270931667
275.42287, 1.635006333
316.227766, 1.077221667
363.078055, 0.628238333
416.869382, 0.316192667
478.630092, 0.110836333
549.540874, 0.017934
630.957344, 0</textarea>
            </div>

            <!-- Fit results -->
            <div class="mt-auto min-h-[190px]">
                <h2 class="text-xl font-semibold text-blue-800 mb-4">Fit Parameters</h2>
                <div id="fit-results-content"></div>
            </div>
        </div>

        <!-- Right Column (Chart) -->
        <div class="md:col-span-2 flex flex-col">
            <h2 id="plotTitle" class="text-xl font-semibold text-blue-800 mb-4 text-center">PSD Plot</h2>
            <div class="relative w-full flex-grow bg-slate-50 p-4 rounded-lg border border-slate-200 shadow-inner">
                <canvas id="myChart"></canvas>
            </div>
        </div>
    </main>
</div>

<!-- New Full-Width Panel -->
<div class="w-full max-w-7xl bg-white rounded-2xl shadow-lg border border-slate-200 overflow-hidden mt-8">
    <div class="p-6 sm:p-8">
        <h2 class="text-xl font-semibold text-blue-800 mb-4">Advanced Model Analysis</h2>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
            <!-- Left: Input -->
            <div class="md:col-span-1">
                <h3 class="text-lg font-semibold text-slate-800 mb-2">Mean volume of coffee beans</h3>
                <div class="flex items-center mt-1">
                    <input type="number" id="meanBeanVolume" value="260" class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                    <span class="ml-2 text-slate-600">(mm³)</span>
                </div>
            </div>
            <!-- Right: Calculation Results -->
            <div class="md:col-span-2">
                 <h3 class="text-lg font-semibold text-slate-800 mb-2">Descriptors</h3>
                 <table class="fit-results-table">
                     <thead>
                         <tr>
                             <th class="w-1/2">Descriptor</th>
                             <th class="w-1/2 text-right">Value</th>
                         </tr>
                     </thead>
                     <tbody>
                         <tr>
                             <td>Hypothetical cuts (<i>n</i>)</td>
                             <td id="hypothetical-cuts-result" class="results-value">-</td>
                         </tr>
                         <tr>
                             <td>Split-ratio (<i>&alpha;</i>)</td>
                             <td id="split-ratio-result" class="results-value">-</td>
                         </tr>
                         <tr>
                             <td>Fines generation-rate (<i>&epsilon;</i>)</td>
                             <td id="fines-generation-rate-result" class="results-value">-</td>
                         </tr>
                     </tbody>
                 </table>
            </div>
        </div>
    </div>
</div>


<script>
/* ───────────────────────── Gaussian & Fitting helpers ───────────────────────── */
function gaussianFunction(x, amplitude, mean, sigma) {
    return amplitude * Math.exp(-Math.pow(x - mean, 2) / (2 * Math.pow(sigma, 2)));
}
function gaussianSum(x, params) {
    let tot = 0;
    for (let i = 0; i < params.length; i += 3) tot += gaussianFunction(x, params[i], params[i+1], params[i+2]);
    return tot;
}
function leastSquares(params, xData, yData) {
    return xData.reduce((s, x, i) => {
        const d = yData[i] - gaussianSum(x, params);
        return s + d*d;
    }, 0);
}
function nelderMead(f, start, maxIter = 2000, tol = 1e-7){
    const n = start.length,a=1,g=2,r=0.5,s=0.5;
    let simplex=[start];
    for(let i=0;i<n;i++){let p=[...start];p[i]=p[i]!==0?p[i]*1.05:0.001;simplex.push(p);}    
    let vals=simplex.map(f);
    for(let iter=0;iter<maxIter;iter++){
        const idx=[...vals.keys()].sort((i,j)=>vals[i]-vals[j]);
        simplex=idx.map(i=>simplex[i]);vals=idx.map(i=>vals[i]);
        if(Math.abs(vals[n]-vals[0])<tol) break;
        const centroid=Array(n).fill(0);
        for(let i=0;i<n;i++) for(let j=0;j<n;j++) centroid[j]+=simplex[i][j]/n;
        const reflect=centroid.map((c,i)=>c+a*(c-simplex[n][i]));
        const fRef=f(reflect);
        if(vals[0]<=fRef&&fRef<vals[n-1]){simplex[n]=reflect;vals[n]=fRef;continue;}
        if(fRef<vals[0]){
            const expand=centroid.map((c,i)=>c+g*(reflect[i]-c));
            const fExp=f(expand);
            simplex[n]=fExp<fRef?expand:reflect;vals[n]=Math.min(fExp,fRef);continue;
        }
        const contract=centroid.map((c,i)=>c+r*(simplex[n][i]-c));
        const fCon=f(contract);
        if(fCon<vals[n]){simplex[n]=contract;vals[n]=fCon;continue;}
        for(let i=1;i<=n;i++){simplex[i]=simplex[i].map((p,j)=>simplex[0][j]+s*(p-simplex[0][j]));vals[i]=f(simplex[i]);}
    }
    return simplex[0];
}

/* ───────────────────────── UI elements & State ───────────────────────── */
const dataInput = document.getElementById('dataInput');
const fitResultsContent = document.getElementById('fit-results-content');
const plotTitle = document.getElementById('plotTitle');
const ctx = document.getElementById('myChart').getContext('2d');
const meanBeanVolumeInput = document.getElementById('meanBeanVolume');
const hypotheticalCutsResult = document.getElementById('hypothetical-cuts-result');
const splitRatioResult = document.getElementById('split-ratio-result');
const finesRateResult = document.getElementById('fines-generation-rate-result');

let chartInstance = null;

function findInitialGuesses(data,numPeaks){
    if(data.x.length<3) return null;
    let residual=[...data.y];const guess=[];
    for(let i=0;i<numPeaks;i++){
        if(residual.every(y=>y<=0)) break;
        const maxY=Math.max(...residual);const idx=residual.indexOf(maxY);if(idx===-1) break;
        const amp=maxY,mean=data.x[idx];
        const half=maxY/2;let i1=idx,i2=idx;
        while(i1>0&&residual[i1]>half) i1--;while(i2<residual.length-1&&residual[i2]>half) i2++;
        const width=data.x[i2]-data.x[i1];let sigma=width/2.355;if(!sigma||sigma<=0) sigma=0.15;
        guess.push(amp,mean,sigma);
        for(let j=0;j<residual.length;j++) residual[j]-=gaussianFunction(data.x[j],amp,mean,sigma);
    }
    return guess.length===numPeaks*3?guess:null;
}

function plotGraph(){
    if(chartInstance) chartInstance.destroy();
    const raw=dataInput.value.trim();
    const numPeaks = 2;
    
    if(!raw){
        displayFitResults(null, numPeaks);
        calculateAndDisplaySecondaryMetrics(null);
        return;
    }

    const lines=raw.split('\n');
    const surfaceAreaPts = [];
    const surfaceFitData = { x: [], y: [] };

    // Parse input data (diameter, surface area)
    lines.forEach(l=>{
        const parts=l.replace(/[,;\s\t]+/g,' ').trim().split(/\s+/);
        if(parts.length===2){
            const d=parseFloat(parts[0]); // diameter
            const s_d=parseFloat(parts[1]); // surface area distribution value
            if(!isNaN(d) && !isNaN(s_d) && d > 0){
                surfaceAreaPts.push({x: d, y: s_d});
                
                // For Surface Area fit
                if (s_d > 0) {
                    surfaceFitData.x.push(Math.log10(d));
                    surfaceFitData.y.push(s_d);
                }
            }
        }
    });

    if(!surfaceAreaPts.length) return;

    const datasets=[{
        label:'Distribution Data',
        data: surfaceAreaPts,
        backgroundColor:'rgba(0,0,0,0.7)',
        borderColor:'rgba(0,0,0,0.7)',
        showLine:false,
        pointRadius:3,
        pointHoverRadius:5,
        pointStyle:'circle'
    }];

    plotTitle.textContent='PSD Plot';

    // --- Perform Fit on Surface Area Data ---
    let surfaceFitParams = null;
    const surfaceGuess = findInitialGuesses(surfaceFitData, numPeaks);
    if(surfaceGuess){
        try {
            const surfaceCost = p => leastSquares(p, surfaceFitData.x, surfaceFitData.y);
            surfaceFitParams = nelderMead(surfaceCost, surfaceGuess);
        } catch(e) {
            console.error("Surface area fit failed:", e);
        }
    }

    // Display results and curves based on the surface area fit
    if (surfaceFitParams) {
        const minX=Math.min(...surfaceAreaPts.map(p=>p.x).filter(x=>x>0));
        const maxX=Math.max(...surfaceAreaPts.map(p=>p.x));
        
        // Generate total fit curve
        const totalFitLine = [];
        for(let i=0; i<200; i++){
            const x = minX*Math.pow(maxX/minX, i/199); 
            const y_surf = gaussianSum(Math.log10(x), surfaceFitParams);
            if (isFinite(y_surf)) totalFitLine.push({x: x, y: y_surf});
        }
        datasets.push({
            label:'Total Fit',
            data: totalFitLine,
            borderColor:'rgba(239,68,68,1)',
            borderWidth:3,
            pointRadius:0,
            showLine:true,
            fill:false,
            pointStyle:'line'
        });

        // Generate individual peak curves
        const colors=['rgba(59,130,246,0.8)','rgba(34,197,94,0.8)'];
        for(let p=0; p<numPeaks; p++){
            const pk = surfaceFitParams.slice(p*3, p*3+3);
            const peakLine = [];
            for(let i=0; i<200; i++){
                const x = minX*Math.pow(maxX/minX,i/199); 
                const y_surf = gaussianFunction(Math.log10(x),...pk);
                 if (isFinite(y_surf)) peakLine.push({x: x, y: y_surf});
            }   
            datasets.push({
                label:`Peak ${p+1}`,
                data: peakLine,
                borderColor:colors[p%colors.length],
                borderWidth:3,
                borderDash:[5,5],
                pointRadius:0,
                showLine:true,
                fill:false,
                pointStyle:'line'
            });
        }
    }
    
    displayFitResults(surfaceFitParams, numPeaks, !surfaceFitParams);
    calculateAndDisplaySecondaryMetrics(surfaceFitParams);

    chartInstance=new Chart(ctx,{type:'scatter',data:{datasets},options:{
        responsive:true,
        maintainAspectRatio:false,
        animation:{duration:0},
        scales:{
            x:{type:'logarithmic',position:'bottom',title:{display:true,text:'Size (µm)',font:{size:16,weight:'bold'}},ticks: { font: { size: 14 } }},
            y:{type:'linear',position:'left',title:{display:true,text:'Distribution',font:{size:16,weight:'bold'}},ticks: { font: { size: 14 } }}
        },
        plugins:{
            legend:{
                display:true,
                labels:{ usePointStyle:true, boxWidth:10, boxHeight:5, font: { size: 14 } }
            },
            tooltip:{
                callbacks:{
                    label(ctx){const l=ctx.dataset.label||'';return `${l}: (Size: ${ctx.parsed.x.toFixed(2)} µm, Dist: ${ctx.parsed.y.toFixed(3)})`;}
                }
            }
        }
    }});
}

function displayFitResults(params,numPeaks,error=false){
    let html='<table class="fit-results-table"><thead><tr><th>Peak #</th><th>Amplitude</th><th>Mean (µm)</th><th>Std Dev (log)</th></tr></thead><tbody>';
    if(error||!params){
        html+='<tr><td colspan="4" class="text-red-600 p-2">Curve fitting failed.</td></tr>';
        for(let i=0;i<numPeaks;i++) html+=`<tr><td>${i+1}</td><td>-</td><td>-</td><td>-</td></tr>`;
    }else{
        const pk=[];for(let i=0;i<params.length;i+=3) pk.push(params.slice(i,i+3));pk.sort((a,b)=>a[1]-b[1]);
        for(let i=0;i<numPeaks;i++) {
            if(pk[i]){
                const [A,M,S]=pk[i];
                html+=`<tr><td>${i+1}</td><td>${A.toFixed(3)}</td><td>${Math.pow(10,M).toFixed(2)}</td><td>${S.toFixed(4)}</td></tr>`;
            } else {
                html+=`<tr><td>${i+1}</td><td>-</td><td>-</td><td>-</td></tr>`;
            }
        }
    }
    html+='</tbody></table>';fitResultsContent.innerHTML=html;
}

// ───────────────── NEW MODEL CALCULATION FUNCTIONS (from Python) ─────────────────

// --- Numerical Integration (Simpson's Rule) ---
function simpsonIntegrate(f, a, b, n = 1000) {
    if (n % 2 !== 0) n++; // n must be even
    const h = (b - a) / n;
    let sum = f(a) + f(b);
    for (let i = 1; i < n; i += 2) sum += 4 * f(a + i * h);
    for (let i = 2; i < n - 1; i += 2) sum += 2 * f(a + i * h);
    return sum * h / 3;
}

// --- Volume Integral from Surface-Area Gaussian Parameters ---
function I_volume(A_peak, D_um, sigma_log10) {
    const mu = Math.log10(D_um);
    const sigma = sigma_log10;
    const LN10 = Math.log(10);
    const SQRT2PI = Math.sqrt(2 * Math.PI);
    return (A_peak / 6.0) * SQRT2PI * sigma * Math.exp(LN10 * mu + 0.5 * Math.pow(LN10 * sigma, 2));
}

// --- Surface-Area Weighted Split-Ratio Moments ---
const mu_sa_cache = {};
function mu_sa(a) {
    if (a <= 1e-9 || a >= 0.5 - 1e-9) return NaN;
    if (mu_sa_cache[a]) return mu_sa_cache[a];

    const num_integrand = r => Math.pow(r, 2/3) * Math.log(r) + Math.pow(1 - r, 2/3) * Math.log(1 - r);
    const den_integrand = r => Math.pow(r, 2/3) + Math.pow(1 - r, 2/3);
    
    const num = simpsonIntegrate(num_integrand, a, 1 - a) / (1 - 2 * a);
    const den = simpsonIntegrate(den_integrand, a, 1 - a) / (1 - 2 * a);

    const result = den !== 0 ? num / den : NaN;
    mu_sa_cache[a] = result;
    return result;
}

const var_sa_cache = {};
function var_sa(a) {
    if (a <= 1e-9 || a >= 0.5 - 1e-9) return NaN;
    if (var_sa_cache[a]) return var_sa_cache[a];

    const num2_integrand = r => Math.pow(r, 2/3) * Math.pow(Math.log(r), 2) + Math.pow(1 - r, 2/3) * Math.pow(Math.log(1 - r), 2);
    const den_integrand = r => Math.pow(r, 2/3) + Math.pow(1 - r, 2/3);

    const num2 = simpsonIntegrate(num2_integrand, a, 1 - a) / (1 - 2 * a);
    const den = simpsonIntegrate(den_integrand, a, 1 - a) / (1 - 2 * a);
    
    const m = mu_sa(a); // Uses caching
    if (isNaN(m) || den === 0) return NaN;

    const result = (num2 / den) - m * m;
    var_sa_cache[a] = result;
    return result;
}

// --- Bisection Solver for Root Finding ---
function bisectionSolver(f, min, max, tolerance = 1e-7, maxIter = 100) {
    let fMin;
    try { fMin = f(min); } catch (e) { return null; }
    let fMax;
    try { fMax = f(max); } catch (e) { return null; }
    if (fMin * fMax >= 0) return null;
    let a = min, b = max, iter = 0;
    while (iter < maxIter) {
        let c = (a + b) / 2;
        if (c === a || c === b) return c; // Precision limit reached
        let fC;
        try { fC = f(c); } catch (e) { return (a + b) / 2; }
        if (Math.abs(fC) < tolerance || (b - a) / 2 < tolerance) return c;
        if (fC * f(a) < 0) { b = c; } else { a = c; }
        iter++;
    }
    return (a + b) / 2;
}


function calculateAndDisplaySecondaryMetrics(surfaceFitParams) {
    // Reset all result fields
    hypotheticalCutsResult.textContent = '-';
    splitRatioResult.textContent = '-';
    finesRateResult.textContent = '-';
    
    // Clear caches for new calculation
    Object.keys(mu_sa_cache).forEach(key => delete mu_sa_cache[key]);
    Object.keys(var_sa_cache).forEach(key => delete var_sa_cache[key]);

    const V0_mm3 = parseFloat(meanBeanVolumeInput.value);

    // Check for valid inputs
    if (!surfaceFitParams || surfaceFitParams.length < 6 || !isFinite(V0_mm3) || V0_mm3 <= 0) {
        return;
    }

    // Sort peaks by mean diameter to identify fine and coarse
    const pk = [];
    for (let i = 0; i < surfaceFitParams.length; i += 3) {
        pk.push(surfaceFitParams.slice(i, i + 3));
    }
    pk.sort((a, b) => a[1] - b[1]); // Sort by mean (log10 scale)

    const [A1, M1_log, s1_log] = pk[0]; // Fine peak
    const [A2, M2_log, s2_log] = pk[1]; // Coarse peak

    const D1_um = Math.pow(10, M1_log);
    const D2_um = Math.pow(10, M2_log);

    // --- ① Calculate fine-volume fraction (φ) ---
    const IV_fine = I_volume(A1, D1_um, s1_log);
    const IV_coarse = I_volume(A2, D2_um, s2_log);
    const phi_fine = (IV_fine + IV_coarse > 0) ? (IV_fine / (IV_fine + IV_coarse)) : NaN;

    // --- ② Estimate split-ratio (a) and hypothetical cuts (n) ---
    const LN10 = Math.log(10);
    const ln_pi_over_6 = Math.log(Math.PI / 6);
    const V0_um3 = V0_mm3 * 1e9;
    const lnV0 = Math.log(V0_um3);

    // Use coarse mode for a and n calculation
    const mean_lnV = ln_pi_over_6 + 3 * LN10 * M2_log;
    const var_lnV = Math.pow(3 * LN10 * s2_log, 2);

    const target = (mean_lnV - lnV0) / var_lnV;
    const funcToSolve = (a) => (mu_sa(a) / var_sa(a)) - target;

    // Find a valid bracket for the solver
    let bracket = null;
    const gridPoints = 200;
    const step = (0.499999 - 1e-6) / gridPoints;
    for (let i = 0; i < gridPoints; i++) {
        const p1 = 1e-6 + i * step;
        const p2 = 1e-6 + (i + 1) * step;
        try {
            const f1 = funcToSolve(p1);
            const f2 = funcToSolve(p2);
            if (f1 * f2 < 0) {
                bracket = [p1, p2];
                break;
            }
        } catch (e) {
            // Ignore points where function is undefined
        }
    }

    let a_est = NaN;
    let n_est = NaN;

    if (bracket) {
        a_est = bisectionSolver(funcToSolve, bracket[0], bracket[1]);
        if (a_est) {
            const var_sa_val = var_sa(a_est);
            if (var_sa_val > 0) {
                n_est = var_lnV / var_sa_val;
            }
        }
    }

    // --- ③ Calculate fines generation-rate (ε) ---
    let epsilon = NaN;
    if (!isNaN(n_est) && n_est > 0 && !isNaN(phi_fine) && phi_fine > 0 && phi_fine < 1) {
        epsilon = 1 - Math.pow(1 - phi_fine, 1 / n_est);
    }

    // --- Display final results ---
    if (!isNaN(n_est)) hypotheticalCutsResult.textContent = n_est.toFixed(2);
    if (!isNaN(a_est)) splitRatioResult.textContent = a_est.toFixed(4);
    if (!isNaN(epsilon)) finesRateResult.textContent = epsilon.toFixed(4);
}


// --- Event Listeners ---
window.onload = plotGraph;
dataInput.addEventListener('input', () => setTimeout(plotGraph, 50));
meanBeanVolumeInput.addEventListener('input', () => setTimeout(plotGraph, 50)); // Recalculate all on volume change

</script>
</body>
</html>
